### Summary

- 1. Typescript for Smashing People

     - Tools to use
     - Setup and Configuration
     - How to resolve "red squiggly lines"

     - TypeScript uses a concept called type inference. The moment we assign a value to a variable, TypeScript tries to infer the type from the assignment

     - TYPE: A type is a classification of data that defines the operations that can be done on that data,
       the meaning of the data, and the set of allowed values. Typing is checked by the compiler and/or run time to ensure the integrity of the data, enforce access restrictions, and interpret the data as meant by the developer.

  - For type declaration create "_.d.ts" and for ambient declaration create "_.ambient.ts"

  - Ambient declaration - To make globals known and defined, we can use ambient type declarations. These types are encompassing, existing and present on all sides.

    - If your TypeScript code needs to use a library that was written with plain JavaScript, you can always write Ambient Declaration that describes the types that would have been there, had it been written in TypeScript. For example, if you had to use a npm package firetruck that looked like this
      `async function extinguish(theta, phi, pressure) { await aimHose(theta, phi); await sprayWater(pressure); }`
      `export default extinguish;`

    You can create a Type Def. file
    // firetruck.d.ts
    `declare function extinguish(theta: number,phi: number, pressure: number): Promise<void>;`
    `export default extinguish;`  
    REFERENCE - https://medium.com/@mikenorth/guide-to-typescript-ambient-declarations-717ef6da6514
    REPO link - https://github.com/mike-north/ambient-type-testing-examples

    While writing Custom Types, please keep in mind that - Inappropriately strict types are more annoying (and more destructive to the code of your users) than inappropriately loose types.

  - Tooling
    - Install typescript globally - `npm install -g typescript`
    - Create a Folder called `@types` into project's root folder, and move type definitions and `ambient` declarations into it.
    - Initi TypeScript configuration file (`tsconfig.json`) - `tsc --init`
    - Add your type declarations in `typeRoots` section = {..., typeRoots: ["@types", "node_modules/@types"]}

- 2. Working with Types

  - Type Annotation
  - Type Inference
  - Primitive (number, boolean, string) and Complex Types (objects, arrays, functions)

  - TypeScript that generates JavaScript is called `emitting`.

  - Left-Hand Typing

    - The moment we annonate using the colon syntax, the name is of the type we annotate.
    - Called `left-hand-typing` as the typing happens before to the EQUAL Sign.
    - Also called as explicit typing.
    - Example - const total: number; const sum: number = 0;

  - Right-Hand Typing -

    - Leaving out the type and working first with the `type inference` is called `right-hand-typing`
    - Typing happens to the right of the equals sign, be it through a VALUE ASSIGNMENT and INFERENCE, or via the type of a function's return value.
    - Example - const table = "TEST" // Type inference - string type

  - `any`

    - `any` is a WILDCARD! ( `any` is the supertype of all types)
    - Type Guards / Control Flow Analysis (CFA) / Narrowing Down (Go down the hierarchy of types from `supertypes` to `subtypes`)
    - We must to Type Checks and Trigger Control Flow Analysis
    - `any` v/s `unknown` - any if flexible; however, `unknown` is inhibiting (we have to provide a proper control analysis)
    - `any` is both carefree and careless, putting type safety into the developer’s hands; unknown requires much more caution and concern.

  - Type guards. Type guards perform run-time checks on types, just like the typeof
    operator makes sure we’re dealing with a number at this point.
  - Control flow analysis. Type guards are used to trig- ger control flow analysis in TypeScript.
    TypeScript can analyze the flow of your program to provide the right types for the next steps.
  - Narrowing down. From the all-encompassing any type, we narrow down to the type number.

  - TypeScript is a structural type system. This means that as long as the defined properties of a type are available in an object, the structural contract is fulfilled.

  - In TypeScript’s type system, the `typeof` operator takes any object (or function, or constant) and extracts the shape of it:
    - Example - `type Order = typeof defaultOrder` - Now `Order`, which has `defaultOrder` shape, can be used anywhere
  - `typeof` is mainly used to do the type checking at the runtime.

  - If you use Classes, both `types` and `interfaces` can be implemented.
  - The Biggest Difference between `types` and `interfaces` is - `DECLARATION MERGING`

  - An example of creating a Type Definition for `Window` Object
    `declare global { interface Window {isDevelopment: boolean }} `

  - TypeScript has two major aspects:
    1. Innovation in a type system that allows the maximum type-safety for all possible JavaScript scenarios.
    2. Provide the first implementation of new JavaScript features that can be transpiled to older versions of ECMAScript. This means that no language innovation happens without the proper process in TC39,15 the ECMAScript standards committee.

- 3. Functions

  - Function Signatures
  - Function Heads
  - Function Bodies
  - Structural Typing for Functions

- 4. Union and Intersection Types

  - Define concrete types for values
  - Perform Algebraic operations on the Types
  - Widening and Narrowing Types
  - Top and Bottom Types

- 5. Generics

  - A way to prepare for the unknown
  - Where we know a certain behaviour of a type but cannot exactly model this behaviour
  - Generic Constraints, Binding Generics, Mapped Types, Type Modifiers

- 6. Conditional Types

- 7. Thinking in Types

  - Real world and Complex Use Cases

- Enable TS in JS file
  - to define a type - /\*_ @type ShipStorage _/
  - enable ts check on the file - // @ts-check
  - Add `@typedef` in JSDoc - /** @typedef { import('./types.d').ShipStorage } ShipStorage **/

KEYWORDS

- TypeScript uses a concept called type inference.
- A Type ensure the integrity of the data and enforce access restrictions
- Javascript is Weakly Typed
- Typescript is Strongly Typed
- Type safety is a way to be very intentional about what types to expect. Makiny Typescript Aware of our Semantics of our program
- Use Ambient Declaration for global flags / thrid party library
- Inappropriately strict types are more annoying (and more destructive to the code of your users) than inappropriately loose types.
- TypeScript Control Flow Analysis (CFA)
  - Type Guard (if else type assignment or checking)
  - Type Guard (`null` Guard, `typeof` Guard, `instanceof` Guard, `in` Guard)
- TypeScript uses a concept called `type inference` to automatically detect types of constants, functions, and variables.
- TypeScript is a `structural type system`, which means that TypeScript cares a lot about the shape or structure of objects and functions.
- Ambient type declarations allowed us to set type information for globals like jQuery or custom environment flags.
- TypeScript that generates JavaScript is called `emitting`.
- We must to Type Checks and Trigger Control Flow Analysis.
- TypeScript is a `structural type system`. This means that as long as the defined properties of a type are available in an object, the structural contract is fulfilled
- While doing an DirectAssignment only, type scrtipt does `excess property check` to esure the structure contract is fulfilled.
- In a structural type system, only the shape is important. Names are sound and smoke.
- Interfaces describing the blueprint of a class

  REFERENCE

- For More Types - https://github.com/DefinitelyTyped/DefinitelyTyped
