### Summary

- 1. Typescript for Smashing People

     - Tools to use
     - Setup and Configuration
     - How to resolve "red squiggly lines"

     - TypeScript uses a concept called type inference. The moment we assign a value to a variable, TypeScript tries to infer the type from the assignment

     - TYPE: A type is a classification of data that defines the operations that can be done on that data,
       the meaning of the data, and the set of allowed values. Typing is checked by the compiler and/or run time to ensure the integrity of the data, enforce access restrictions, and interpret the data as meant by the developer.

  - For type declaration create "_.d.ts" and for ambient declaration create "_.ambient.ts"

  - Ambient declaration - To make globals known and defined, we can use ambient type declarations. These types are encompassing, existing and present on all sides.

    - If your TypeScript code needs to use a library that was written with plain JavaScript, you can always write Ambient Declaration that describes the types that would have been there, had it been written in TypeScript. For example, if you had to use a npm package firetruck that looked like this
      `async function extinguish(theta, phi, pressure) { await aimHose(theta, phi); await sprayWater(pressure); }`
      `export default extinguish;`

    You can create a Type Def. file
    // firetruck.d.ts
    `declare function extinguish(theta: number,phi: number, pressure: number): Promise<void>;`
    `export default extinguish;`  
    REFERENCE - https://medium.com/@mikenorth/guide-to-typescript-ambient-declarations-717ef6da6514
    REPO link - https://github.com/mike-north/ambient-type-testing-examples

    While writing Custom Types, please keep in mind that - Inappropriately strict types are more annoying (and more destructive to the code of your users) than inappropriately loose types.

  - Tooling
    - Install typescript globally - `npm install -g typescript`
    - Create a Folder called `@types` into project's root folder, and move type definitions and `ambient` declarations into it.
    - Initi TypeScript configuration file (`tsconfig.json`) - `tsc --init`
    - Add your type declarations in `typeRoots` section = {..., typeRoots: ["@types", "node_modules/@types"]}

- 2. Working with Types

  - Type Annotation
  - Type Inference
  - Primitive (number, boolean, string) and Complex Types (objects, arrays, functions)

  - TypeScript that generates JavaScript is called `emitting`.

  - Left-Hand Typing

    - The moment we annonate using the colon syntax, the name is of the type we annotate.
    - Called `left-hand-typing` as the typing happens before to the EQUAL Sign.
    - Also called as explicit typing.
    - Example - const total: number; const sum: number = 0;

  - Right-Hand Typing -

    - Leaving out the type and working first with the `type inference` is called `right-hand-typing`
    - Typing happens to the right of the equals sign, be it through a VALUE ASSIGNMENT and INFERENCE, or via the type of a function's return value.
    - Example - const table = "TEST" // Type inference - string type

  - `any`

    - `any` is a WILDCARD! ( `any` is the supertype of all types)
    - Type Guards / Control Flow Analysis (CFA) / Narrowing Down (Go down the hierarchy of types from `supertypes` to `subtypes`)
    - We must to Type Checks and Trigger Control Flow Analysis
    - `any` v/s `unknown` - any if flexible; however, `unknown` is inhibiting (we have to provide a proper control analysis)
    - `any` is both carefree and careless, putting type safety into the developer’s hands; unknown requires much more caution and concern.

  - Type guards. Type guards perform run-time checks on types, just like the typeof
    operator makes sure we’re dealing with a number at this point.
  - Control flow analysis. Type guards are used to trig- ger control flow analysis in TypeScript.
    TypeScript can analyze the flow of your program to provide the right types for the next steps.
  - Narrowing down. From the all-encompassing any type, we narrow down to the type number.

  - TypeScript is a structural type system. This means that as long as the defined properties of a type are available in an object, the structural contract is fulfilled.

  - In TypeScript’s type system, the `typeof` operator takes any object (or function, or constant) and extracts the shape of it:
    - Example - `type Order = typeof defaultOrder` - Now `Order`, which has `defaultOrder` shape, can be used anywhere
  - `typeof` is mainly used to do the type checking at the runtime.

  - If you use Classes, both `types` and `interfaces` can be implemented.
  - The Biggest Difference between `types` and `interfaces` is - `DECLARATION MERGING`

  - An example of creating a Type Definition for `Window` Object
    `declare global { interface Window {isDevelopment: boolean }} `

  - TypeScript has two major aspects:

    1. Innovation in a type system that allows the maximum type-safety for all possible JavaScript scenarios.
    2. Provide the first implementation of new JavaScript features that can be transpiled to older versions of ECMAScript. This means that no language innovation happens without the proper process in TC39,15 the ECMAScript standards committee.

  - Property Access Modifiers
  - Abstract Classes
    - When interfaces describe the blueprint of implementations, and classes are implmentations,
      Abstract classes are something in-between.
  - Enum - Allow you to bundle a couple of types and use them throught your code.
    They have one significant aspect: they contribute to both the type-creation space and the value-creation space, emit-ting code. Occasionally. Adding a const keyword before enum UserType prevents code emitting.

  - Interface
    - One major difference between type aliases vs interfaces are that interfaces are open and type aliases are closed.
      This means you can extend an interface by declaring it a second time.
      // These two declarations become:
      // interface Point { x: number; y: number; }
      interface Point { x: number; }; interface Point { y: number; };
    - A class can implement an interface or type alias, both in the same exact way.
      Note however that a class and interface are considered static blueprints. Therefore, they can not implement / extend a type alias that names a union type.  
      Refer - https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript/52682220#52682220

- 3. Functions

  - Function Signatures
  - Function Heads
  - Function Bodies
  - Structural Typing for Functions

  - Functions contribute to the value-creation space of TypeScript.
  - Their parameters have types, which are any by default and can be inferred from default values.
  - The return values have types; they can be inferred from the actual value that we return in the function body.
  - An easy way to get and use the type of function is

    - `type FnType = typeof <function-name>` - `FnType` has the type def. of function

  - Function Types with Overloads
    type SearchOverloadFn = {
    // Function overload number 1 (
    term: string, tags?: string[] | undefined ) : Promise<Result[]>;
    // Function overload number 2 (
    term: string, callback: (results: Result[]) => void, tags?: string[] | undefined ): void;
    }

    const searchWithOverloads: SearchOverloadFn = (....)

- 4. Union and Intersection Types

  - Define concrete types for values
  - Perform Algebraic operations on the Types
  - Widening and Narrowing Types
  - Top and Bottom Types
  - Mapped Types
    `type GroupedEvents = {[Kind in EventKind]: TechEvent[]}`

  - Object Keys

    - `keyof` Operator
    - Example:
      // 'speaker' | 'title' | 'abstract'
      `type TalkProperties = keyof Talk`

      // number | 'toString' | 'charAt' | ...
      `type StringKeys = keyof 'speaker'`

      // number | 'length' | 'pop' | 'push' | ...
      `type ArrayKeys = keyof []`

  - Type Predicates

    - Type predicates are a way to add more information to control flow analysis. We can extend the possibilities of narrowing down by telling TypeScript that if we do a certain check, we can be sure our variables are of a certain type. Type predicates work with functions that return a Boolean.
      Example: `function(value:string) : category is keyof UserEvents`

  - `never`
    - `never` behaves pretty much like the anti-type of `any`. Where- as `any` accepts all values and all operations on those values, `never` doesn’t accept a single value at all.

- `undefined` and `null`

  - Both `null` and `undefined` denote the absence of a value. `undefined` tells us that a variable or property has been declared, but no value has been assigned. `null`, on the other hand, is an empty value that can be assigned to clear a variable or property. Both values are known as bottom values, values that have no actual value.

- Object
- `declare function useToggleState(id: number): { state: boolean, updateState: () => void };`
- `const { state, updateState } = useToggleState(1)` //Possible
- `const { state, updateState } = useToggleState(1)` // Error - Those variables are already declared!

- Array // tuples
- `declare function useToggleState(id: number): [boolean, () => void]`
- `const [ first, updateFirst ] = useToggleState(1)` //Possible
- `const [ second, updateSecond ] = useToggleState(2)` //Possible

- 5. Generics

  - A way to prepare for the unknown
  - Where we know a certain behaviour of a type but cannot exactly model this behaviour
  - Generic Constraints, Binding Generics, Mapped Types, Type Modifiers
  - Generic is a style of computer programming in which algorithms are written in terms of types to- be-specified-later that are then instantiated when needed for specific types provided as parameters

  - Generic Annotations and Generic Inference
    Example: Promise<number>, Array<Animal>

  - Generic Constraints

    - We use it to Defining Boundaries, by substituting with a specific type, the type set gets narrower and cleaner.
      `function isAvailable<FormatList extends object>( obj: FormatList, key: string)` - Index Types
      Index types don’t define specific property keys. They just define a set of keys they iterate over. We can also accept the entire set of strings as keys.
      Example: `type AnyObject = { [k: string]: URL }`

  - Generic Mapped Types

    - TypeScript has a couple of helper types that can be used

    1. Pick: Pick<O, K> creates a new object with selected property keys K of object O.
    2. Record: Record<K, T> creates an object type where all types in T get the type K. Like a dictionary.
    3. Optional / Partial - `type Optional<Obj> = {[Key in keyof Obj]?: Obj[Key]}`
    4. Required - `type Required<Obj> = { [Key in Obj]-?: Obj[Key]}`
    5. Read Only - ` type Const<Obj> = {readonly [Key in Obj]: Obj[Key]}`
    6. Extract - `type Extract<A, B> = A extends B ? A : never`

    `function combinePreferences<Defaults extends UserPreferences, UserPref extends Partial<UserPreferences>>`

  - Generic Default Params and Type Inference
    `declare function createVid<GElement extends HTMLElement = HTMLVideoElement>`

- 6. Conditional Types

  - The syntax for conditional types is based on generics and is as follows
    `type Conditional<T> = T extends U ? A : B`
    `type FetchReturn<Param extends FetchParams> = Param extends Customer ? Order[] :Param extends Product ? Order[] : Order`
    `function fetchOrder<Param extends FetchParams>( param: Param): FetchReturn<Param> {// Well, the implementation}`

  - Distributive Conditionals
    `type FetchReturn<Param extends FetchParams> = Param extends Customer ? Order[] :Param extends Product ? Order[] : Order`

  - Naked Types
    - An important precondition to distributive conditional types is that the generic type parameter is a naked type. Naked type is type system jargon and means that the type parame- ter is present as is, without being part of any other construct. (use of tuple [])
      `type FetchReturn<Param extends FetchParams> = [Param] extends [Customer] ? Order[] : [Param] extends [Product] ? Order[] : Order`

- 7. Thinking in Types

  - Real world and Complex Use Cases

- Enable TS in JS file
  - to define a type - /\*_ @type ShipStorage _/
  - enable ts check on the file - // @ts-check
  - Add `@typedef` in JSDoc - /** @typedef { import('./types.d').ShipStorage } ShipStorage **/

KEYWORDS

- TypeScript uses a concept called type inference.
- A Type ensure the integrity of the data and enforce access restrictions
- Javascript is Weakly Typed
- Typescript is Strongly Typed
- Type safety is a way to be very intentional about what types to expect. Makiny Typescript Aware of our Semantics of our program
- Use Ambient Declaration for global flags / thrid party library
- Inappropriately strict types are more annoying (and more destructive to the code of your users) than inappropriately loose types.
- TypeScript Control Flow Analysis (CFA)
  - Type Guard (if else type assignment or checking)
  - Type Guard (`null` Guard, `typeof` Guard, `instanceof` Guard, `in` Guard)
- TypeScript uses a concept called `type inference` to automatically detect types of constants, functions, and variables.
- TypeScript is a `structural type system`, which means that TypeScript cares a lot about the shape or structure of objects and functions.
- Ambient type declarations allowed us to set type information for globals like jQuery or custom environment flags.
- TypeScript that generates JavaScript is called `emitting`.
- We must to Type Checks and Trigger Control Flow Analysis.
- TypeScript is a `structural type system`. This means that as long as the defined properties of a type are available in an object, the structural contract is fulfilled
- While doing an DirectAssignment only, type scrtipt does `excess property check` to esure the structure contract is fulfilled.
- In a structural type system, only the shape is important. Names are sound and smoke.
- Interfaces describing the blueprint of a class
- Classes are the Implementations.
- Abstract Classes are something in-between Interfaces and Classes
- Enum allow you to bundle a couple of types and use them throughour your code.
- `type-creation` space (type definition), `value-creation` space (generated code)
- Functions contribute to the value-creation space of TypeScript.
- Promises are called promises because they promise to resolve to a value
- Generator functions can be exited and later reentered. The idea is that such a function generates values over the course of time, hence its name.
- Both `null` and `undefined` denote the absence of a value. `undefined` tells us that a variable or property has been declared, but no value has been assigned. `null`, on the other hand, is an empty value that can be assigned to clear a variable or property.
- Both values are known as bottom values, values that have no actual value.

  REFERENCE

- For More Types - https://github.com/DefinitelyTyped/DefinitelyTyped
